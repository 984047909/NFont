<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <title>Character/Glyph Index Mapping</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="STYLESHEET" href="otspec.css" type="text/css">
  </head>
  <body>
    <div class="toprule">
    </div>
    <p class="menu">
      <a href="http://www.microsoft.com/typography/default.mspx">Microsoft 版式</a> | <a href="http://www.microsoft.com/typography/creators.htm">开发者...</a> | <a href="default.htm">OpenType 规范</a> | <a href="otff.htm#otttables">OpenType 表</a> | cmap 表</p>
    <div class="middlerule">
    </div>
    <div class="contents">
      <h1>cmap - Character To Glyph Index Mapping Table/cmap-字符到标志符号索引的映射表</h1>
      <p>此表定义字符代码的映射到使用该字体中的标志符号索引值。它可能包含多个子表，以支持多个字符编码方案。应将不对应于任何标志符号字体中的字符代码映射到标志符号索引为 0。标志符号在此位置必须是一个特别的标志符号，表示缺少的字符，通常被称为.notdef。</p>
      <p>表头指示为其中多个子表中是存在的字符编码。每个子表七个可能的格式之一，指示使用的格式的格式代码的开头。</p>
      <p>平台 ID 和平台特定编码 ID 中的标头条目 （和在 Macintosh 平台，在子表本身的语言字段的情况下） 用于指定特定的 'cmap' 的编码。通过平台 ID，然后按特定于平台的编码 ID，然后在相应的子表中的语言字段，必须先排序标头条目。每个平台 ID、 平台特定编码 ID 和子表的语言组合可能只出现一次 'cmap'表中。</p>
      <p>当 Windows 为建设一个 Unicode 字体，平台 ID 应该是 3 和编码 ID 应该是 1。在生成时的符号字体为 Windows，平台 ID 应该是 3 和编码 ID 应该是 0。当建立一种字体，将使用在 Macintosh 上时，平台 ID 应该是 1 和编码 ID 应该是 0。</p>
      <p>所有 Microsoft Unicode BMP 编码 （Platform ID = 3，Encoding ID = 1） 必须提供至少一个 Format 4 'cmap' 子表。如果字体要支持补充 (non-BMP) Unicode 字符，它将另外一个 encoding ID 10 的平台需要 Format 12 子表。Format 12 子表的内容必须是 Format 4 子表的内容的一个超集。Microsoft<b>强烈</b>建议使用 BMP Unicode 'cmap' 的所有字体。但是，在当前字体中出现的一些其他编码遵循：</p>
      <table class="gray">
        <caption>Windows Encodings/Windows 的编码</caption>
        <tr>
          <th style="width: 33%;">Platform ID/平台 ID</th>
          <th style="width: 33%;">Encoding ID/编码 ID</th>
          <th style="width: 33%;">Description/说明</th>
        </tr>
        <tr>
          <td>3</td>
          <td>0</td>
          <td>Symbol/符号</td>
        </tr>
        <tr>
          <td>3</td>
          <td>1</td>
          <td>Unicode BMP (UCS-2)</td>
        </tr>
        <tr>
          <td>3</td>
          <td>2</td>
          <td>ShiftJIS</td>
        </tr>
        <tr>
          <td>3</td>
          <td>3</td>
          <td>PRC/中华人民共和国</td>
        </tr>
        <tr>
          <td>3</td>
          <td>4</td>
          <td>Big5</td>
        </tr>
        <tr>
          <td>3</td>
          <td>5</td>
          <td>Wansung</td>
        </tr>
        <tr>
          <td>3</td>
          <td>6</td>
          <td>Johab/韩文</td>
        </tr>
        <tr>
          <td>3</td>
          <td>7</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>3</td>
          <td>8</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>3</td>
          <td>9</td>
          <td>Reserved</td>
        </tr>
        <tr>
          <td>3</td>
          <td>10</td>
          <td>Unicode UCS-4</td>
        </tr>
      </table>
      <p>支持的字体的 Unicode 变异序列可能只根据platform ID 0 cmap 表和encoding ID 5，使用 format 14 cmap 子表中指定。</p>
      <p>The Character To Glyph Index Mapping Table is organized as follows:/字符到标志符号索引映射表的组织形式如下：</p>
      <table class="gray">
        <caption>cmap Header/cmap 标头</caption>
        <tr>
          <th style="width: 25%;">Type</th>
          <th style="width: 25%;">Name</th>
          <th style="width: 66%;">Description</th>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>version</td>
          <td>Table version number (0)./表版本号 (0)。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>numTables</td>
          <td>Number of encoding tables that follow./遵循的编码表的数量。</td>
        </tr>
      </table>
      <p>Cmap 表头被其次的编码指定的特定编码的记录和到子表为该编码的偏移量数组。编码记录的数目是<i>numTables</i>。编码的记录条目看起来如下：</p>
      <table class="gray">
        <caption>Encoding Record</caption>
        <tr>
          <th style="width: 25%;">Type</th>
          <th style="width: 25%;">Name</th>
          <th style="width: 50%;">Description</th>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>platformID</td>
          <td>Platform ID./平台 id。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>encodingID</td>
          <td>Platform-specific encoding ID./编码 id： 特定于平台。</td>
        </tr>
        <tr>
          <td>ULONG</td>
          <td>offset</td>
          <td>Byte offset from beginning of table to the subtable for this encoding./字节偏移量从开始的表到子表为此编码。</td>
        </tr>
      </table>
      <p>'name' 表的说明。</p>
      <h2>
        <a name="cust" id="cust">OTF Windows NT compatibility mapping: /OTF Windows NT 兼容性映射：</a>
      </h2>
      <p>如果一个platform ID 4 （自定义）, encoding ID 0-255 (OTF Windows NT 兼容性映射) 'cmap' 编码 目前在 OpenType 字体 CFF 轮廓, 然后 OTF 字体驱动程序在 Windows NT 中将： (a) 将叠加编码 Unicode 编码它向系统 ； 报告中的字符码 0-255 中的编码上相应的 Windows ANSI （代码页 1252年） Unicode 值的字形 (b) 将 Windows ANSI （字符集 0） 添加到列表中的数据支持的字体 ；和 (c) 考虑编码 ID 是一个 Windows 字符集的值并将它添加到的数据支持的字体列表中的值。注： 'cmap' 子表及其子表，必须使用 0 或 6 的格式和编码必须与 CFF 的编码相同。</p>
      <p>此 'cmap' 编码不是必需的。它提供了一个使用的字体，好象它是 Windows ANSI 编码的非 Unicode 应用程序的兼容性机制。非 Windows ANSI 类型 1 的字体，如西里尔文和中欧的字体，Adobe 在过去附带了"0"（Windows ANSI） 录得的 CharSet 字段。PFM 文件 ；ATM 为 Windows 9 x 一共忽略字符集。Adobe 提供了这种兼容性 'cmap' 中每个 OTF 转换从 Type1 字体的编码不是 StandardEncoding 的编码。</p>
      <h2 id="language">Note on the language field in 'cmap' subtables:/关于 'cmap' 各个子表中的语言字段说明：</h2>
      <p>关于 'cmap' 各个子表中的语言字段的说明： 语言字段必须设置为零，为所有的感觉神经 subtables Id 是 Macintosh （platform ID 1） 以外的平台。为其平台 Id 是 Macintosh 的感觉神经子表说明，此字段设置为的感觉神经子表加一，Macintosh 的语言 ID，或为零如果 cmap 子表不是特定于语言。例如，Mac OS 土耳其 cmap 子表必须设置此字段到 18 岁，因为土耳其的 Macintosh 的语言 ID 是 17。Mac OS 罗马 cmap 子表必须将此字段设置为 0，因为 Mac OS 罗马不特定于语言编码。</p>
      <h2>Format 0: Byte encoding table/Format 0: 字节编码表</h2>
      <p>这是 苹果标准 字符到标志符号索引的映射表。</p>
      <table class="gray">
        <tr>
          <th style="width: 33%;">Type/类型</th>
          <th style="width: 33%;">Name/名称</th>
          <th style="width: 33%;">Description/说明</th>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>format</td>
          <td>Format number is set to 0./设置数字格式设置为 0。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>length</td>
          <td>This is the length in bytes of the subtable./	这是子表的长度以字节为单位）。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>language</td>
          <td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document./请参阅本文档中的&ldquo;<a href="#language">关于 'cmap' 各个子表中的语言字段的说明</a>&ldquo;。</td>
        </tr>
        <tr>
          <td>BYTE</td>
          <td>glyphIdArray[256]</td>
          <td>An array that maps character codes to glyph index values./将字符代码映射到标志符号索引值的数组。</td>
        </tr>
      </table>
      <p>这是简单的 1 对 1 映射的标志符号索引到的字符代码。字形集被限制为 256。请注意，如果使用这种格式要索引到一个较大的标志符号集，只有首先 256 的标志符号将可以访问。</p>
      <h2>Format 2: High-byte mapping through table/ Format 2：通过表的高字节映射</h2>
      <p>此子表非常有用的用于日语、 汉语和朝鲜语字符的国家字符代码标准。这些代码标准使用混合 8 16 位编码、 在哪个某些字节值信号一个 2 字节字符的首字节 （但这些值也是法律作为一个 2 字节字符的第二个字节）。</p>
      <p>此外，甚至对于双字节字符，字符代码为标志符号索引值的映射严重依赖的第一个字节。因此，表的开头到 4 字 subHeader 地图的第一个字节的数组。为 2 个字节的字符代码，subHeader 用来通过一个子数组的第二个字节的值映射如下所述。在处理混合的 8 16 位文本时，subHeader 0 是特别： 它用于单字节的字符代码。当使用了 subHeader 为零，则不需要第二个字节 ；通过子数组映射单个字节值。</p>
      <table class="gray">
        <tr>
          <th style="width: 25%;">Type/类型</th>
          <th style="width: 25%;">Name/名称</th>
          <th style="width: 50%;">Description/说明</th>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>format</td>
          <td>Format number is set to 2./设置数字格式设置为 2。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>length</td>
          <td>This is the length in bytes of the subtable./这是子表的长度以字节为单位）。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>language</td>
          <td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document./请参阅本文档中的&ldquo;<a href="#language">关于 'cmap' 各个子表中的语言字段的说明</a>&ldquo;。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>subHeaderKeys[256]</td>
          <td>Array that maps high bytes to subHeaders: value is subHeader index * 8./映射到的副标题的高字节的数组： 值是 subHeader 的索引 * 8。</td>
        </tr>
        <tr>
          <td>4 words struct</td>
          <td>subHeaders[ ]</td>
          <td>Variable-length array of subHeader structures./可变长度的 subHeader 结构的数组。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>glyphIndexArray[ ]</td>
          <td>Variable-length array containing subarrays used for mapping the low byte of 2-byte characters./可变长度数组，其中包含用来映射的低字节的 2 字节字符的子数组。</td>
        </tr>
      </table>
      <p>SubHeader 的结构如下：</p>
      <table class="gray">
        <tr>
          <th style="width: 25%;">Type/类型</th>
          <th style="width: 25%;">Name/名称</th>
          <th style="width: 50%;">Description/说明</th>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>firstCode</td>
          <td>First valid low byte for this subHeader./第一次有效的低字节为此 subHeader 的。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>entryCount</td>
          <td>Number of valid low bytes for this subHeader./为此 subHeader 有效低字节数。</td>
        </tr>
        <tr>
          <td>SHORT</td>
          <td>idDelta</td>
          <td>See text below./请参阅下面的文本。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>idRangeOffset</td>
          <td>See text below./请参阅下面的文本。</td>
        </tr>
      </table>
      <p>FirstCode 和 entryCount 的值指定的子范围，开始在 firstCode 和 entryCount 的值相等的长度。此子范围保持在 0-255 范围内的被映射的字节范围。在此子范围的字节映射到标志符号索引 0 （缺少标志符号）。在此子范围内的字节偏移量然后用作索引到相应的子数组的 glyphIndexArray。此子数组的长度 entryCount 也是。IdRangeOffset 的值是过去的 idRangeOffset 一词的实际位置对应于 firstCode 的 glyphIndexArray 元素的显示位置的字节数。</p>
      <p>最后，如果值是从获得子数组不是 0 （这表明缺少标志符号），您应将 idDelta 添加到它，为了得到 glyphIndex。值 idDelta 允许相同的子数组，用于几个不同的副标题。算术 idDelta 是模数 65536。</p>
      <h2>Format 4: Segment mapping to delta values/Format 4: 部分映射到增量值</h2>
      <p>这是微软标准字符到标志符号索引映射表为支持 Unicode 范围之外定义的范围 [U + D800-U + DFFF] (作为替身领域，在 Unicode v 3.0)，用于 UCS 4 字符的字体。如果字体支持此字符范围 （即反过来支持 UCS 4 字符） 创建子表在此格式的具体编码 ID 1 尚未需要的除了创建子表中的一个平台的格式与平台特定编码 ID 10 12。请查看下面，在 Windows 上支持 UCS 4 字符的字体格式 12 的详细信息。</p>
      <p>这种格式使用时为代表的一种字体的字符的字符代码分为几个连续的范围，可能与在某些或所有范围的孔 （就是一个范围中的代码的一些可能没有一个表示字体中）。格式依赖于数据被划分成三个部分，必须按以下顺序发生：</p>
      <ol>
        <li>four-word header给出参数的优化搜索的部分列表 ；</li>
        <li>Four parallel arrays 描述线段 （一个部分为代码的每个连续的范围） ；</li>
        <li>A variable-length array of glyph IDs (unsigned words)。</li>
      </ol>
      <table class="gray">
        <tr>
          <th style="width: 20%;">Type/类型</th>
          <th style="width: 30%;">Name/名称</th>
          <th style="width: 50%;">Description/说明</th>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>format</td>
          <td>Format number is set to 4./设置数字格式设置为 4。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>length</td>
          <td>This is the length in bytes of the subtable./这是子表的长度以字节为单位）。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>language</td>
          <td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document./请参阅本文档中的&ldquo;<a href="#language">关于 'cmap' 各个子表中的语言字段的说明</a>&ldquo; 。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>segCountX2</td>
          <td>2 x segCount.</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>searchRange</td>
          <td>2 x (2**floor(log2(segCount)))</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>entrySelector</td>
          <td>log2(searchRange/2)</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>rangeShift</td>
          <td>2 x segCount - searchRange</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>endCount[segCount]</td>
          <td>End characterCode for each segment, last=0xFFFF./结束每个线段的 characterCode，最后 = 0xFFFF。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>reservedPad</td>
          <td>Set to 0./设置为 0。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>startCount[segCount]</td>
          <td>Start character code for each segment./开始每个段的字符代码。</td>
        </tr>
        <tr>
          <td>SHORT</td>
          <td>idDelta[segCount]</td>
          <td>Delta for all character codes in segment./段中的所有字符代码的三角洲。</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>idRangeOffset[segCount]</td>
          <td>Offsets into glyphIdArray or 0/偏移到 glyphIdArray 或 0</td>
        </tr>
        <tr>
          <td>USHORT</td>
          <td>glyphIdArray[ ]</td>
          <td>Glyph index array (arbitrary length)/标志符号索引数组 （任意长度）</td>
        </tr>
      </table>
      <p>The number of segments is specified by segCount, which is not explicitly in the header; however, all of the header parameters are derived from it. The searchRange value is twice the largest power of 2 that is less than or equal to segCount. For example, if segCount=39, we have the following:/SegCount，未显式标头 ； 中由指定的段数然而，所有的标头参数从它派生。SearchRange 的值是两次最大的力量 2，小于或等于 segCount。例如，如果 segCount = 39，我们有以下内容：</p>
      <table>
        <tr>
          <td>segCountX2</td>
          <td>78</td>
        </tr>
        <tr>
          <td>searchRange</td>
          <td>64</td>
          <td>(2 * largest power of 2 &lt;=39)</td>
        </tr>
        <tr>
          <td>entrySelector</td>
          <td>5</td>
          <td>log<sub>2</sub> (32)</td>
        </tr>
        <tr>
          <td>rangeShift</td>
          <td>14</td>
          <td>2 x 39 - 64</td>
        </tr>
      </table>
      <p>每个部分是由 startCode 和 endCode 以及 idDelta 和 idRangeOffset，用于映射的字符代码段中描述的。各段按顺序增加 endCode 值的排序和段值数组指定的四个平行。您搜索的是大于第一次 endCode 或要等于字符代码映射。如果相应的 startCode 是小于或等于的字符代码，则您使用的相应的 idDelta 和 idRangeOffset，将字符代码映射到一个标志符号索引 （否则，返回 missingGlyph）。终止，搜索，最后 endCode 值必须为 0xFFFF。这一段不需要包含任何有效的映射。（它可以只是映射 0xFFFF 的单个字符代码为 missingGlyph)。然而，部分必须存在。.</p>
      <p>如果部分的 idRangeOffset 值不是 0，映射的字符代码依赖于 glyphIdArray。从 startCode 的字符代码偏移量被添加到 idRangeOffset 的值。这笔款项作为偏移量从 idRangeOffset 本身内的当前位置给出正确的 glyphIdArray 值的索引。这个默默无闻的索引把戏工程因为 glyphIdArray 紧跟在后面的字体文件中的 idRangeOffset。生成的标志符号索引 C 表达式是：</p>
      <pre>*(idRangeOffset[i]/2 
+ (c - startCount[i]) 
+ &amp;idRangeOffset[i])
</pre>
      <p>值<i>c</i>是问题，该字符代码， <i>c</i>出现在其中的部分索引。如果从索引操作获取的值不是 0 （这表明 missingGlyph），idDelta [i] 添加到它来获取标志符号索引。算术 idDelta 是模数 65536。</p>
      <p>如果 idRangeOffset 为 0，idDelta 的值是直接添加的字符代码偏移 (i.e. <tt>idDelta[i] + c</tt>) 来获取相应的标志符号索引。再次，算术 idDelta 是模数 65536。</p>
      <p>举一个例子，要 10-20、 30-90 和 153-480 到一个连续的标志符号索引范围的字符映射表的变型部件可能像这样：</p>
      <table>
        <tr>
          <td>segCountX2:</td>
          <td>8</td>
        </tr>
        <tr>
          <td>searchRange:</td>
          <td>8</td>
        </tr>
        <tr>
          <td>entrySelector:</td>
          <td>4</td>
        </tr>
        <tr>
          <td>rangeShift:</td>
          <td>0</td>
        </tr>
        <tr>
          <td>endCode:</td>
          <td>20</td>
          <td>90</td>
          <td>480</td>
          <td>0Xffff</td>
        </tr>
        <tr>
          <td>reservedPad:</td>
          <td>0</td>
        </tr>
        <tr>
          <td>startCode:</td>
          <td>10</td>
          <td>30</td>
          <td>153</td>
          <td>0Xffff</td>
        </tr>
        <tr>
          <td>idDelta:</td>
          <td>-9</td>
          <td>-18</td>
          <td>-27</td>
          <td>1</td>
        </tr>
        <tr>
          <td>idRangeOffset:</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
      </table>&nbsp;<p>此表执行以下映射：</p><pre>10 &rArr; 10 - 9 = 1 
20 &rArr; 20 - 9 = 11
30 &rArr; 30 - 18 = 12
90 &rArr; 90 - 18 = 72
...and so on.
</pre><p>请注意，以重新排列各段可以整顿了的增量值。</p>

<h2>Format 6: Trimmed table mapping</h2>
<table class="gray">
<tr>
<th style="width: 25%;">Type</th>
<th style="width: 25%;">Name</th>
<th style="width: 50%;">Description</th>
</tr>
<tr>
<td>USHORT</td>
<td>format</td>
<td>Format number is set to 6.</td>
</tr>
<tr><td>USHORT</td><td>length</td><td>This is the length in bytes of the subtable.</td></tr><tr><td>USHORT</td><td>language</td><td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document.</td></tr><tr><td>USHORT</td><td>firstCode</td><td>First character code of subrange.</td></tr><tr><td>USHORT</td><td>entryCount</td><td>Number of character codes in subrange.</td></tr><tr><td>USHORT</td><td>glyphIdArray [entryCount]</td><td>Array of glyph index values for character codes in the range.</td></tr></table><p>The firstCode and entryCount values specify a subrange (beginning at firstCode,length = entryCount) within the range of possible character codes. Codes outside of this subrange are mapped to glyph index 0. The offset of the code (from the first code) within this subrange is used as index to the glyphIdArray, which provides the glyph index value.</p><h1>Supporting 4-byte character codes</h1><p>While the four existing 'cmap' subtable formats which currently exist have served us well, the introduction of the Surrogates Area in Unicode 2.0 has stressed them past the point of utility. This section specifies three formats, format 8, 10 and 12; which directly support 4-byte character codes. A major change introduced with these three formats is a more pure 32-bit orientation. The 'cmap' table version number will continue to be 0x0000, for those fonts that make use of these formats.</p><h2>Format 8: mixed 16-bit and 32-bit coverage</h2><p>Format 8 is a bit like format 2, in that it provides for mixed-length character codes. If a font contains characters from the Unicode Surrogates Area (U+D800-U+DFFF), which are UCS-4 characters; it's likely that it will also include other, regular 16-bit Unicodes as well. We therefore need a format to map a mixture of 16-bit and 32-bit character codes, just as format 2 allows a mixture of 8-bit and 16-bit codes. A simplifying assumption is made: namely, that there are no 32-bit character codes which share the same first 16 bits as any 16-bit character code. This means that the determination as to whether a particular 16-bit value is a standalone character code or the start of a 32-bit character code can be made by looking at the 16-bit value directly, with no further information required.</p><p>Here's the format 8 subtable format:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td>USHORT</td><td>format</td><td>Subtable format; set to 8.</td></tr><tr><td>USHORT</td><td>reserved</td><td>Reserved; set to 0</td></tr><tr><td>ULONG</td><td>length</td><td>Byte length of this subtable (including the header)</td></tr><tr><td>ULONG</td><td>language</td><td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document.</td></tr><tr><td> BYTE</td><td>is32[8192]<br></td><td> Tightly packed array of bits (8K bytes total) indicating whether the particular 16-bit (index) value is the start of a 32-bit character code</td></tr><tr><td> ULONG</td><td> nGroups</td><td> Number of groupings which follow</td></tr></table><p>Here follow the individual groups. Each group has the following format:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> ULONG</td><td> startCharCode</td><td> First character code in this group; note that if this group is for one or more 16-bit character codes (which is determined from the is32 array), this 32-bit value will have the high 16-bits set to zero</td></tr><tr><td> ULONG</td><td> endCharCode</td><td> Last character code in this group; same condition as listed above for the startCharCode</td></tr><tr><td> ULONG</td><td> startGlyphID</td><td> Glyph index corresponding to the starting character code</td></tr></table><p>A few notes here. The endCharCode is used, rather than a count, because comparisons for group matching are usually done on an existing character code, and having the endCharCode be there explicitly saves the necessity of an addition per group. Groups must be sorted by increasing startCharCode. A group's endCharCode must be less than the startCharCode of the following group, if any.</p><p>To determine if a particular word (cp) is the first half of 32-bit code points, one can use an expression such as ( is32[ cp / 8 ] &amp; ( 1 &lt;&lt; ( 7 - ( cp % 8 ) ) ) ). If this is non-zero, then the word is the first half of a 32-bit code point.</p><p>0 is not a special value for the high word of a 32-bit code point. A font may not have both a glyph for the code point 0x0000 and glyphs for code points with a high word of 0x0000.</p><p>The presence of the packed array of bits indicating whether a particular 16-bit value is the start of a 32-bit character code is useful even when the font contains no glyphs for a particular 16-bit start value. This is because the system software often needs to know how many bytes ahead the next character begins, even if the current character maps to the missing glyph. By including this information explicitly in this table, no &ldquo;secret&rdquo; knowledge needs to be encoded into the OS.</p><p>Although this format might work advantageously on some platforms for non-Unicode encodings, Microsoft does not support it for Unicode encoded UCS-4 characters.</p><h2>Format 10: Trimmed array</h2><p>Format 10 is a bit like format 6, in that it defines a trimmed array for a tight range of 32-bit character codes:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td>USHORT</td><td>format</td><td>Subtable format; set to 10.</td></tr><tr><td>USHORT</td><td>reserved</td><td>Reserved; set to 0</td></tr><tr><td> ULONG</td><td> length</td><td> Byte length of this subtable (including the header)</td></tr><tr><td>ULONG</td><td>language</td><td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document.</td></tr><tr><td> ULONG</td><td> startCharCode</td><td> First character code covered</td></tr><tr><td> ULONG</td><td> numChars</td><td> Number of character codes covered</td></tr><tr><td> USHORT</td><td> glyphs[]</td><td> Array of glyph indices for the character codes covered</td></tr></table><p>This format is not supported by Microsoft.</p><h2>Format 12: Segmented coverage</h2><p>This is the Microsoft standard character to glyph index mapping table for fonts supporting the UCS-4 characters in the Unicode Surrogates Area (U+D800 - U+DFFF). It is a bit like format 4, in that it defines segments for sparse representation in 4-byte character space. Here's the subtable format:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td>USHORT</td><td>format</td><td>Subtable format; set to 12.</td></tr><tr><td>USHORT</td><td>reserved</td><td>Reserved; set to 0</td></tr><tr><td> ULONG</td><td> length</td><td> Byte length of this subtable (including the header)</td></tr><tr><td>ULONG</td><td>language</td><td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document.</td></tr><tr><td> ULONG</td><td> nGroups</td><td> Number of groupings which follow</td></tr></table><p>Fonts providing Unicode encoded UCS-4 character support for Windows 2000 and later, need to have a subtable with platform ID 3, platform specific encoding ID 1 in format 4; and in addition, need to have a subtable for platform ID 3, platform specific encoding ID 10 in format 12. Please note, that the content of format 12 subtable, needs to be a super set of the content in the format 4 subtable. The format 4 subtable needs to be in the cmap table to enable backward compatibility needs.</p><p>Here follow the individual groups, each of which has the following format:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> ULONG</td><td> startCharCode</td><td> First character code in this group</td></tr><tr><td> ULONG</td><td> endCharCode</td><td> Last character code in this group</td></tr><tr><td> ULONG</td><td> startGlyphID</td><td> Glyph index corresponding to the starting character code</td></tr></table><p>Groups must be sorted by increasing startCharCode. A group's endCharCode must be less than the startCharCode of the following group, if any. The endCharCode is used, rather than a count, because comparisons for group matching are usually done on an existing character code, and having the endCharCode be there explicitly saves the necessity of an addition per group.</p><h2>Format 13: Last Resort Font</h2><p>This subtable deals with situations where the same glyph is used for dozens or even tens of thousands of consecutive characters, from one end of Unicode to the other. This is common when creating a &ldquo;Last Resort&rdquo; font. Here's the subtable format:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td>USHORT</td><td>format</td><td>Subtable format; set to 13.</td></tr><tr><td>USHORT</td><td>reserved</td><td>Reserved; set to 0</td></tr><tr><td> ULONG</td><td> length</td><td> Byte length of this subtable (including the header)</td></tr><tr><td>ULONG</td><td>language</td><td>Please see &ldquo;<a href="#language">Note on the language field in 'cmap' subtables</a>&ldquo; in this document.</td></tr><tr><td> ULONG</td><td> nGroups</td><td> Number of groupings which follow</td></tr></table><p>Here follow the individual groups, each of which has the following format:</p><table class="gray"><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> ULONG</td><td> startCharCode</td><td> First character code in this group</td></tr><tr><td> ULONG</td><td> endCharCode</td><td> Last character code in this group</td></tr><tr><td> ULONG</td><td> glyphID</td><td>Glyph index to be used for all the characters in the group's range.</td></tr></table><h2>Format 14: Unicode Variation Sequences</h2><p>Subtable format 14 specifies the Unicode Variation Sequences (UVSes) supported by the font. A Variation Sequence, according to the Unicode Standard, comprises a base character followed by a variation selector; e.g. &lt;U+82A6, U+E0101&gt;.</p><p>The subtable partitions the UVSes supported by the font into two categories: &ldquo;default&rdquo; and &ldquo;non-default&rdquo; UVSes. Given a UVS, if the glyph obtained by looking up the base character of that sequence in the Unicode cmap subtable (i.e. the UCS-4 or the BMP cmap subtable) is the glyph to use for that sequence, then the sequence is a &ldquo;default&rdquo; UVS; otherwise it is a &ldquo;non-default&rdquo; UVS, and the glyph to use for that sequence is specified in the format 14 subtable itself.</p><p>The example at the bottom of the page shows how a font vendor can use format 14 for a JIS-2004–aware font.</p><table class="gray"><caption>Format 14 header</caption><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td>USHORT</td><td>format</td><td>Subtable format. Set to 14.</td></tr><tr><td>ULONG</td><td>length</td><td>Byte length of this subtable (including this header)</td></tr><tr><td>ULONG</td><td>numVarSelectorRecords</td><td>Number of variation Selector Records</td></tr></table><p>This is immediately followed by &lsquo;numVarSelectorRecords&rsquo; Variation Selector Records.</p><table class="gray"><caption>Variation Selector Record</caption><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> UINT24</td><td> varSelector</td><td>Variation selector</td></tr><tr><td>ULONG</td><td>defaultUVSOffset</td><td>Offset to Default UVS Table. May be 0.</td></tr><tr><td>ULONG</td><td>nonDefaultUVSOffset</td><td>Offset to Non-Default UVS Table. May be 0.</td></tr></table><p>The Variation Selector Records are sorted in increasing order of &lsquo;varSelector&rsquo;. No two records may have the same &lsquo;varSelector&rsquo;. All offsets in a record are relative to the beginning of the format 14 cmap subtable.</p><p>A Variation Selector Record and the data its offsets point to specify those UVSes supported by the font for which the variation selector is the &lsquo;varSelector&rsquo; value of the record. The base characters of the UVSes are stored in the tables pointed to by the offsets. The UVSes are partitioned by whether they are default or non-default UVSes.</p><p>Glyph IDs to be used for non-default UVSes are specified in the Non-Default UVS table.</p><h2>Default UVS Table</h2><p>A Default UVS Table is simply a range-compressed list of Unicode scalar values, representing the base characters of the default UVSes which use the &lsquo;varSelector&rsquo; of the associated Variation Selector Record.</p><table class="gray"><caption>Default UVS Table header</caption><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td>ULONG</td><td>numUnicodeValueRanges</td><td>Number of ranges that follow</td></tr></table><p>This is immediately followed by &lsquo;numUnicodeValueRanges&rsquo; Unicode Value Ranges, each of which represents a contiguous range of Unicode values.</p><table class="gray"><caption>Unicode Value Range</caption><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> UINT24</td><td> startUnicodeValue</td><td> First value in this range</td></tr><tr><td> BYTE</td><td> additionalCount</td><td> Number of additional values in this range</td></tr></table><p>For example, the range U+4E4D–U+4E4F (3 values) will set &lsquo;startUnicodeValue&rsquo; to 0x004E4D and &lsquo;additionalCount&rsquo; to 2. A singleton range will set &lsquo;additionalCount&rsquo; to 0.</p><p>(&lsquo;startUnicodeValue&rsquo; + &lsquo;additionalCount&rsquo;) must not exceed 0xFFFFFF.</p><p>The Unicode Value Ranges are sorted in increasing order of &lsquo;startUnicodeValue&rsquo;. The ranges must not overlap; i.e., (&lsquo;startUnicodeValue&rsquo; + &lsquo;additionalCount&rsquo;) must be less than the &lsquo;startUnicodeValue&rsquo; of the following range (if any).</p><h2>Non-Default UVS Table</h2><p>A Non-Default UVS Table is a list of pairs of Unicode scalar values and glyph IDs. The Unicode values represent the base characters of all non-default UVSes which use the &lsquo;varSelector&rsquo; of the associated Variation Selector Record, and the glyph IDs specify the glyph IDs to use for the UVSes.</p><table class="gray"><caption>Non-Default UVS Table header</caption><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> ULONG</td><td> numUVSMappings</td><td> Number of UVS Mappings that follow</td></tr></table><p>This is immediately followed by &lsquo;numUVSMappings&rsquo; UVS Mappings.</p><table class="gray"><caption>UVS Mapping</caption><tr><th style="width: 25%;">Type</th><th style="width: 25%;">Name</th><th style="width: 50%;">Description</th></tr><tr><td> UINT24</td><td> unicodeValue</td><td> Base Unicode value of the UVS</td></tr><tr><td> USHORT</td><td> glyphID</td><td> Glyph ID of the UVS</td></tr></table><p>The UVS Mappings are sorted in increasing order of &lsquo;unicodeValue&rsquo;. No two mappings in this table may have the same &lsquo;unicodeValue&rsquo; values.</p><h2>Example</h2><p>Here is an example of how a format 14 cmap subtable may be used in a font that is aware of JIS-2004 variant glyphs. The CIDs (character IDs) in this example refer to those in the Adobe Character Collection &ldquo;Adobe-Japan1&rdquo;, and may be assumed to be identical to the glyph IDs in the font in our example.</p><p>JIS-2004 changed the default glyph variants for some of its code points. For example:</p><p>JIS-90: U+82A6 &rArr; CID 1142 <br>JIS-2004: U+82A6 &rArr; CID 7961</p><p>Both of these glyph variants are supported through the use of UVSes, as the following examples from Unicode&rsquo;s UVS registry show:</p><p>U+82A6 U+E0100 &rArr; CID 1142 <br>U+82A6 U+E0101 &rArr; CID 7961</p><p>If the font wants to support the JIS-2004 variants by default, it will:</p><ul><li>encode glyph ID 7961 at U+82A6 in the Unicode cmap subtable,</li><li>specify &lt;U+82A6, U+E0101&gt; in the UVS cmap subtable&rsquo;s Default UVS Table (&lsquo;varSelector&rsquo; will be 0x0E0101 and &lsquo;defaultUVSOffset&rsquo; will point to data containing a 0x0082A6 Unicode value)</li><li>specify &lt;U+82A6, U+E0100&gt; &rArr; glyph ID 1142 in the UVS cmap subtable&rsquo;s Non-Default UVS Table (&lsquo;varSelector&rsquo; will be 0x0E0100 and &lsquo;nonDefaultBaseUVOffset&rsquo; will point to data containing a &lsquo;unicodeValue&rsquo; 0x0082A6 and &lsquo;glyphID&rsquo; 1142).</li></ul><p>If, however, the font wants to support the JIS-90 variants by default, it will:</p><ul><li>encode glyph ID 1142 at U+82A6 in the Unicode cmap subtable,</li><li>specify &lt;U+82A6, U+E0100&gt; in the UVS cmap subtable&rsquo;s Default UVS Table</li><li>specify &lt;U+82A6, U+E0101&gt; &rArr; glyph ID 7961 in the UVS cmap subtable&rsquo;s Non-Default UVS Table</li></ul><hr class="separator"><p class="fineprint">This page was last updated 20 November 2008.</p><p class="fineprint">&copy; 2008 Microsoft Corporation. All rights reserved. <a href="http://www.microsoft.com/Misc/cpyright.htm">Terms of use</a>.</p><p class="fineprint">Comments to the MST group: <a href="/typography/AboutMST.mspx">how to contact us</a>.</p></div>
    <div class="middlerule">
    </div>
    <p class="menu">
      <a href="http://www.microsoft.com/typography/default.mspx">Microsoft Typography</a> | <a href="http://www.microsoft.com/typography/creators.htm">Developer...</a> | <a href="default.htm">OpenType specification</a> | <a href="otff.htm#otttables">OpenType tables</a> | The cmap table</p>
    <div class="bottomrule">
    </div>
  </body>
</html>
